---
title: "Creating tutorial worksheets; Quarto profiles for the win!"
author: Package Build
date: '2025-07-07'
slug: quarto-profiles-for-tutorials
categories:
  - Blog
tags:
  - Quarto
  - R
  - R Markdown
  - Stata
  - nbstata
  - Python
  - Julia
  - Jupyter
subtitle: ''
summary: ""
authors: []
lastmod: '2025-07-05T07:00:00+00:00'
featured: no
image:
  caption: ''
  focal_point: 'Center'
  preview_only: no
  alt_text: 'Screenshot of .'
projects: []
toc: true
---

## Introduction

I [previously posted](https://remlapmot.github.io/post/2025/quarto-conditional-content/) about creating tutorial worksheets for 4 different Quarto engines using [conditional content](https://quarto.org/docs/authoring/conditional.html). However, that approach is a bit hacky and I wasn't very happy with it.

Thanks to a [vignette by Christophe Devrieux](https://quarto-dev.github.io/quarto-r/articles/dynamic-metadata.html) in the quarto R package I realised there is a more convenient (and indeed less hacky) way to create tutorial documents using Quarto profiles (I don't use the approach in the vignette but it led me to relevant Quarto documentation page).

My aim is the following

> Have a single Quarto document from which both the question and solution documents can be rendered for a tutorial.

As a reminder, as I showed in my previous post, this has long been trivial with R Markdown and knitr because they allow programmtic chunk options. Therefore, implementing this in a Quarto document using the knitr engine is also trivial. However, it is other Quarto engines which are problematic because as far as I know they don't allow programmtic chunk options and they don't the equivalent of `!expr`.

## Quarto profiles

Profiles documents [on this page](https://quarto.org/docs/projects/profiles.html).

And specifically, we shall make use of [conditional content dependent upon profile](https://quarto.org/docs/projects/profiles.html#profile-content).

*_quarto.yml*

```yml
execute:
  eval: true
```

*_quarto-python-questions.yml*

```yml
title: 'Questions document: Python version'
execute:
  eval: false
```

*_quarto-python-solutions.yml*

```yml
title: 'Solutions document: Python version'
```

Then our tutorial Quarto Python document, *tutorial-python.qmd*, will look like the following.

````{verbatim, lang="plaintext"}
---
format:
  html:
    embed-resources: true
jupyter: python3
---

## Question 1

Question text.

```{python}
print("The code which is echoed in questions and evaluated in solutions.")
```

::: {.content-visible unless-profile="python-questions"}
The text for the solutions.
:::

````

We see the use of the conditional content based upon profile for the text of the solutions, and indeed we could included additional code chunks in these divs.

We repeat this for the other 2 tricky Quarto engines, `engine: julia` and `jupyter: nbstata`, including making profile yaml files for each engine.

Then we make a shell script with our render commands.

```sh
quarto render tutorial-python.qmd --profile python-questions -o tutorial-python-questions.html
quarto render tutorial-python.qmd --profile python-solutions -o tutorial-python-solutions.html
```

And because I have an version using parameters my shell script usually begins.

```sh
quarto render tutorial-r.qmd -P solutions:false -o tutorial-r-questions.html
quarto render tutorial-r.qmd -o tutorial-r-solutions.html
```

And remarkably that's it.

## An honorable mention about dynamic metadata

https://quarto.org/docs/authoring/conditional.html#matching-against-metadata

## Summary

I have shown how to create Quarto profiles for creating tutorial worksheets; one for the questions and one for the solutions from the same Quarto document; for several Quarto engines (`knitr`, `jupyter: python3`, `jupyter: nbstata`, and `engine: julia`). I have also shown how additional metadata may be written into your Quarto document in these engines which can be used in conjunction with parameterised documents.
