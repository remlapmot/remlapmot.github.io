---
title: "Creating tutorial worksheets; Quarto profiles for the win!"
author: Package Build
date: '2025-07-07'
slug: quarto-profiles-for-tutorials
categories:
  - Blog
tags:
  - Quarto
  - R
  - R Markdown
  - Stata
  - nbstata
  - Python
  - Julia
  - Jupyter
subtitle: ''
summary: ""
authors: []
lastmod: '2025-07-05T07:00:00+00:00'
featured: no
image:
  caption: ''
  focal_point: 'Center'
  preview_only: no
  alt_text: 'Screenshot of .'
projects: []
toc: true
---

## Introduction

I [previously posted](https://remlapmot.github.io/post/2025/quarto-conditional-content/) about creating tutorial worksheets for 4 different Quarto engines using [conditional content](https://quarto.org/docs/authoring/conditional.html). However, that approach is a bit hacky and I wasn't very happy with it.

Thanks to a [vignette by Christophe Devrieux](https://quarto-dev.github.io/quarto-r/articles/dynamic-metadata.html) in the quarto R package I realised there is a more convenient (and indeed less hacky) way to create tutorial documents using Quarto profiles (I don't use the approach in the vignette but it led me to relevant Quarto documentation page).

My aim is the following

> Have a single Quarto document from which both the question and solution documents can be rendered for a tutorial.

As a reminder, as I showed in my previous post, this has long been trivial with R Markdown and knitr because they allow programmtic chunk options. Therefore, implementing this in a Quarto document using the knitr engine is also trivial. However, it is other Quarto engines which are problematic because as far as I know they don't allow programmtic chunk options and they don't the equivalent of `!expr`.

## Quarto profiles

Profiles documents [on this page](https://quarto.org/docs/projects/profiles.html).

And specifically, we shall make use of [conditional content dependent upon profile](https://quarto.org/docs/projects/profiles.html#profile-content).

*_quarto.yml*

```yml
execute:
  eval: true
```

*_quarto-python-questions.yml*

```yml
project:
  render:
    - tutorial-python.qmd
title: 'Questions document: Python version'
execute:
  eval: false
```

*_quarto-python-solutions.yml*

```yml
project:
  render:
    - tutorial-python.qmd
title: 'Solutions document: Python version'
```

Then our tutorial Quarto Python document, *tutorial-python.qmd*, will look like the following.

````{verbatim, lang="plaintext"}
---
format:
  html:
    embed-resources: true
jupyter: python3
---

## Question 1

Question text.

```{python}
print("The code which is echoed in questions and evaluated in solutions.")
```

::: {.content-visible unless-profile="python-questions"}
The text for the solutions.
:::

````

We see the use of the conditional content based upon profile for the text of the solutions, and indeed we could included additional code chunks in these divs.

We repeat this for the other 2 tricky Quarto engines, `engine: julia` and `jupyter: nbstata`, including making profile yaml files for each engine.

Then we make a shell script with our render commands.

```sh
quarto render --profile python-questions -o tutorial-python-questions.html
quarto render --profile python-solutions -o tutorial-python-solutions.html
```

And because I have an R version using parameters my shell script usually begins.

```sh
quarto render tutorial-r.qmd -P solutions:false -o tutorial-r-questions.html
quarto render tutorial-r.qmd -o tutorial-r-solutions.html
```

And that's it.

## An honorable mention about dynamic metadata

When I started reading the quarto R package vignette I began trying to use dynamic metadata to achieve the result above. Dynamic metadata involves writing extra YAML blocks into your Quarto document which can include programmatically specified values of parameters, which can then be used by including conditional content by [matching against them](https://quarto.org/docs/authoring/conditional.html#matching-against-metadata). I found that I could achieve except modifying the `execute` state, as that must be specified in the first YAML header.

For Quarto documents using the knitr engine, the R package vignette shows how to use the new `write_yaml_metadata_block()` function with an R code chunk with output type `asis` to write the YAML block. In case it is useful to anyone, below I show examples of how to write the YAML blocks in each of the three other engines I have been using.

### Python

````{verbatim, language='plaintext'}
```{python}
#| include: false
#| tags: [parameters]
solutions = 'true'
```

```{python}
#| include: false
from IPython.display import Markdown
ymltxt = f"  solutions: {solutions}"
if solutions == 'true':
    titletxt = "title: Solutions document"
else:
    titletxt = "title: Questions document"
```

`{python} Markdown("---")`
`{python} Markdown("params:")`
`{python} Markdown(ymltxt)`
`{python} Markdown(titletxt)`
`{python} Markdown("---")`

::: {.content-visible when-meta="params.solutions"}
```{python}
print("A solution, which is hidden in questions")
```
:::

````

### Stata

````{verbatim, language='plaintext'}
```{stata}
*| include: false
local solutions : env SOLUTIONS_STATA
scalar ymltxt = "  solutions: `solutions'"
if "`solutions'" == "true" {
  scalar titletxt = "title: Solutions document"
}
else {
  scalar titletxt = "title: Questions document"
}
```

`{stata} "---"`
`{stata} "params:"`
`{stata} scalar(ymltxt)`
`{stata} scalar(titletxt)`
`{stata} "---"`

::: {.content-visible when-meta="params.solutions"}
```{stata}
display "A solution, which is hidden in questions"
```
:::
````

### Julia

````{verbatim, language='plaintext'}
```{julia}
#| tags: [parameters]
```

```{julia}
#| echo: false
#| output: asis
println("---")
if solutions
  println("title: Solutions document")
  ymltxt = "  solutions: true"
else
  println("title: Questions document")
  ymltxt = "  solutions: false"
end
println("params:")
println(ymltxt)
println("---")
```

::: {.content-visible when-meta="params.solutions"}
```{julia}
println("A solution, hidden in questions")
```
:::

````

## Summary

I have shown how to create Quarto profiles for creating tutorial worksheets; one for the questions and one for the solutions from the same Quarto document; for several Quarto engines (`knitr`, `jupyter: python3`, `jupyter: nbstata`, and `engine: julia`). I have also shown how additional metadata may be written into your Quarto document in these engines which can be used in conjunction with parameterised documents.
